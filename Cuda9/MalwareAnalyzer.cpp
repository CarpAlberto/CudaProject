#include "MalwareAnalyzer.h"
#include "NeuralNetwork.h"
#include "OptimizedNeuralNetwork.h"
#include <fstream>
#include "StringModel.h"
#include "NeuralNetworkTest.h"

using namespace gpuNN;

vStrings PEIterator::ss;
parsed_pe * PEIterator::pe;

extern std::vector<const char*> gpuNN::excludedImports = { 
	"MSVCP140D.DLL",
	"MSVCP140.DLL",
	"MSVCP120.DLL",
	"MSVCP120D.DLL",
	"API-MS-WIN-CRT-PRIVATE-L1-1-0.DLL",
	"NTDLL.DLL",
	"MSYS-2.0.DLL",
	"VCRUNTIME140.DLL"
};

extern std::vector<const char*> gpuNN::excludedStrings = {
	"NULL",
	"std",
	"ORDINAL_MFC42U",
	"xml",
	"str",
	"@"
};

extern  std::vector<std::string> gpuNN::filteredStrings = {
	"@",
	"ORDINAL_MFC42U.DLL",
	"xml",
	"str",
	"_",
	"wbkgd",
	"wresize",
	"log2",
	"pow2",
	"tanhf",
	"sinhf",
	"gl",
	"memcpy",
	"memset",
	"memove",
	"wcschr",
	"memcmp",
	"wcscmp",
	"fprintf",
	"fflush",
	"fclose",
	"fwrite",
	"wcsncmp",
	"feof",
	"fgets",
	"fputc",
	"fseek",
	"ferror",
	"fgetc",
	"rand",
	"fputs",
	"puts",
	"perror",
	"raise",
	"putchar",
	"fscanf",
	"vfprintf",
	"malloc",
	"free",
	"exit",
	"fwprintf",
	"abort",
	"Gdip",
	"exp",
	"acos",
	"tanh",
	"asin",
	"sscanf",
	"fmodf",
	"powf",
	"modf",
	"tan",
	"wcsnlen",
	"printf",
	"towupper",
	"wcstol",
	"getc",
	"fread",
	"setvbuf",
	"iswalpha",
	"wcstok",
	"atoi",
	"wcsrchr",
	"realloc",
	"calloc",
	"towlower",
	"iswdigit",
	"tolower",
	"fopen",
	"wcspbrk",
	"wcsspn",
	"isalpha",
	"fgetwc",
	"isalnum",
	"memchr",
	"isupper",
	"ObjectStublessClient",
	"isprint",
	"isxdigit",
	"ftell",
	"logf",
	"ceilf",
	"wcsncpy",
	"putc",
	"iswprint"
};

MalwareAnalyzer::MalwareAnalyzer()
{

}

MalwareAnalyzer::~MalwareAnalyzer()
{
}

void MalwareAnalyzer::Analyze(INeuralNetwork* network)
{	
	network->Train(this->iterationNumber);	
}

vStrings MalwareAnalyzer::LoadStringsFromExe(parsed_pe* pe)
{
	IterImpVAString(pe,PEIterator::printImports,NULL);
	
	//IterSec(pe, PEIterator::printSecs, NULL);

	auto vArray = PEIterator::ss;

	return std::move(PEIterator::ss);
}

void MalwareAnalyzer::BuildFeatures(const std::string& filename, 
	INeuralNetwork*& network, bool isBening )
{
	parsed_pe *p = ParsePEFromFile(filename.c_str());
	PEIterator::pe = p;
	if (p == nullptr)
		return; // no pe format maybe
	auto arrayStrings = LoadStringsFromExe(p);
	if (arrayStrings.size() == 0)
		return;
	auto& sequenceModel = this->wordProcessor.BuildModel(arrayStrings);
	
	auto vModel = sequenceModel.toVector();
	auto context = ApplicationContext::instance();
	auto mode = context->getConfiguration()->getMode();

	if (mode == "CPU" || mode == "GPU")
	{
		/*Create a topology with size of the array as input and two outputs*/
		std::vector<size_t> topology = { vModel.size(),8,8,8,8,2 };
		network = new NeuralNetwork(topology, 1, 0.05, 1);
		network->SetCurrentInput(vModel);
		network->SetCurrentTarget({1});
	}

	if (mode == "OPTIMIZED_GPU")
	{
		RealHostMatrix input(1, vModel.size());

		for (auto i = 0; i < vModel.size(); i++) {
			input(0, i) = vModel[i];
		}
		
		RealHostMatrix outputs(1, 1);
		if(isBening)
			outputs(0,0) = 1.0f;
		else
			outputs(0, 0) = 0.0f;
		
		TopologyOptimized topology(4);
		
		topology[0] = vModel.size();
		topology[1] = 30;
		topology[2] = 10;
		topology[3] = 1;

		network = new OptimizedNeuralNetwork(topology, input, outputs, 0.7,0.001);
		
	}


}

void MalwareAnalyzer::BuildFeatures(const std::string& filename, const std::string& out){
	
	parsed_pe *p = ParsePEFromFile(filename.c_str());
	PEIterator::pe = p;
	if (p == nullptr)
		return; // no pe format maybe
	auto arrayStrings = LoadStringsFromExe(p);
	auto& sequenceModel = this->wordProcessor.BuildModel(arrayStrings);

	ISequenceModel* model = new StringModel(arrayStrings);

	auto vModel = model->toVector();
	std::ofstream os(out);
	for (auto & iterator : vModel) {
		os << iterator;
	}
	os.close();
}

void MalwareAnalyzer::BuildFeaturesFromDirectory(const std::string& directory, 
	const std::string& database)
{
	std::vector<std::string> vArray;
	Utils::ReadDirectory(directory, vArray);
	std::string s;
	int index = 0;
	int size = vArray.size();
	for (auto & filename : vArray) 
	{
		if (filename == "." || filename == "..") 
			continue;
		parsed_pe *p = ParsePEFromFile((directory + "\\" + filename).c_str());
		PEIterator::pe = p;
		if (p == nullptr)
		{
			
			std::cout << "Filename: " + filename + "no pe" << std::endl;
			continue; // no pe format maybe
		}
		auto arrayStrings = LoadStringsFromExe(p);

		this->wordProcessor.CreateAndAppendModel(arrayStrings);
		std::cout << "Processing file " + filename + " " + 
			std::to_string((float)index / size) << std::endl;
		index++;
	}


	this->wordProcessor.OnFinish(database);


}

void MalwareAnalyzer::TrainNeuralNetwork(const std::string& file,const std::string& filename, bool save)
{
	std::ifstream Stream(file);
	size_t benignsLines = Utils::getNumberLines(Stream);
	auto config = ApplicationContext::instance()->getConfiguration();
	auto noEpocks = config->getEpocksLimit();
	auto mRMS = config->getRootMeanSquareMin();
	auto directory = config->getDirectoryBase();
	auto directoryTest = directory + config->getTestDirectory();
	auto mode = config->getMode();
	RealHostMatrix benign, benign_small;
	std::vector<RealHostMatrix> d_smallArray;
	int size = 505;
	int chunk = 1;
	std::string line;
	int i = 0;
	
	benign.ResizeWithoutPreservingData(benignsLines, size);
	benign_small.ResizeWithoutPreservingData(1, size);
	while (std::getline(Stream, line)) {
		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			benign_small(0, index) = strtod(it.c_str(), 0);
			index++;
		}
		d_smallArray.push_back(benign_small);
		i++;
	}

	RealHostMatrix desiredOutputs(chunk, 1);
	int nOutputs = (int)desiredOutputs.Columns();
	std::vector<RealCpuArray> array;
	auto classes = (nOutputs == 1) ? 2 : nOutputs;
	NeuralNetworkTest test(classes);

	for (auto i = 0; i < chunk; i++)
		desiredOutputs(i, 0) = 0.0f;

	int sizeInputs = benign.Columns();
	TopologyOptimized topology(3);
	topology[0] = size;
	topology[1] = 25;
	topology[2] = 1;
	int j = 0;
	int index = 0;
	OptimizedNeuralNetwork* network = nullptr;
	while (j < d_smallArray.size())
	{
		network = new OptimizedNeuralNetwork(topology, d_smallArray[j], desiredOutputs, 0.5, 0.001);
		array.reserve(network->GetNumbersLayers());
		index = 0;
		if (array.size() == network->GetNumbersLayers())
		{
			for (int i = 0; i < network->GetNumbersLayers();i++) {
				network->SetWeights(array[i],i);
			}
		}
	TRAIN:
		index++;
		network->Train(1);
		auto rms = network->GetRMS();
		std::cout << "Inputs: " << j << " ";
		std::cout << "Epochs: " << network->GetEpoch() << " ";
		std::cout << "RMS: " << rms << std::endl;		
		if (rms > 0.01) {
			goto TRAIN;

		}
		
		for (auto k = 0; k < network->GetNumbersLayers(); k++) {
			RealCpuArray weights = network->GetWeights(k);
			if (array.size() == network->GetNumbersLayers())
				array[k] = weights;
			else
				array.push_back(weights);
		}
		j++;
		
		if (j == 590)
			break;
		else
			delete network;
	}
	
	desiredOutputs(0, 0) = 0;
	
	float treeshold = 0.0018;
	TestNeuralNetwork(directoryTest + "\\benigns.txt", *network, desiredOutputs, treeshold,true);
	
	desiredOutputs(0, 0) = 1;
	TestNeuralNetwork(directoryTest + "\\malware.txt", *network, desiredOutputs, treeshold,false);
	
	if (save)
		network->Save(filename, IOStrategy::ASCII);
}

float MalwareAnalyzer::TrainNeuralNetwork(const std::string& file, const std::string& rhs,
	float hiddenLayer, float rms, float treeshold)
{
	std::ifstream Stream(file);
	size_t benignsLines = Utils::getNumberLines(Stream);
	auto config = ApplicationContext::instance()->getConfiguration();
	auto noEpocks = config->getEpocksLimit();
	auto mRMS = config->getRootMeanSquareMin();
	auto directory = config->getDirectoryBase();
	auto directoryTest = directory + config->getTestDirectory();
	auto mode = config->getMode();
	RealHostMatrix benign, benign_small;
	std::vector<RealHostMatrix> d_smallArray;
	int size = 505;
	int chunk = 1;
	std::string line;
	int i = 0;

	benign.ResizeWithoutPreservingData(benignsLines, size);
	benign_small.ResizeWithoutPreservingData(1, size);
	while (std::getline(Stream, line)) {
		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			benign_small(0, index) = strtod(it.c_str(), 0);
			index++;
		}
		d_smallArray.push_back(benign_small);
		i++;
	}

	RealHostMatrix desiredOutputs(chunk, 1);
	int nOutputs = (int)desiredOutputs.Columns();
	std::vector<RealCpuArray> array;
	auto classes = (nOutputs == 1) ? 2 : nOutputs;
	NeuralNetworkTest test(classes);

	for (auto i = 0; i < chunk; i++)
		desiredOutputs(i, 0) = 0.0f;

	int sizeInputs = benign.Columns();
	TopologyOptimized topology(3);
	topology[0] = size;
	topology[1] = hiddenLayer;
	topology[2] = 1;
	int j = 0;
	int index = 0;
	OptimizedNeuralNetwork* network = nullptr;
	while (j < d_smallArray.size())
	{
		network = new OptimizedNeuralNetwork(topology, d_smallArray[j], desiredOutputs, 0.5, 0.001);
		array.reserve(network->GetNumbersLayers());
		index = 0;
		if (array.size() == network->GetNumbersLayers())
		{
			for (int i = 0; i < network->GetNumbersLayers(); i++) {
				network->SetWeights(array[i], i);
			}
		}
	TRAIN:
		index++;
		network->Train(1);
		auto rms = network->GetRMS();
		//std::cout << "Inputs: " << j << " ";
		//std::cout << "Epochs: " << network->GetEpoch() << " ";
		//std::cout << "RMS: " << rms << std::endl;
		if (rms > rms) {
			goto TRAIN;

		}

		for (auto k = 0; k < network->GetNumbersLayers(); k++) {
			RealCpuArray weights = network->GetWeights(k);
			if (array.size() == network->GetNumbersLayers())
				array[k] = weights;
			else
				array.push_back(weights);
		}
		j++;

		if (j == 590)
			break;
		else
			delete network;
	}

	desiredOutputs(0, 0) = 0;

	float bAccuracy = TestNeuralNetwork(directoryTest + "\\benigns.txt", *network, desiredOutputs, treeshold, true);

	desiredOutputs(0, 0) = 1;
	bAccuracy += TestNeuralNetwork(directoryTest + "\\malware.txt", *network, desiredOutputs, treeshold, false);

	return (float)(bAccuracy / 2);
}

float MalwareAnalyzer::TestNeuralNetwork(const std::string& file, OptimizedNeuralNetwork& n,
	RealHostMatrix desiredOutputs,float minValue,bool direction)
{
	std::ifstream Stream(file);
	size_t benignsLines = Utils::getNumberLines(Stream);
	auto config = ApplicationContext::instance()->getConfiguration();
	auto noEpocks = config->getEpocksLimit();
	auto mRMS = config->getRootMeanSquareMin();
	auto mode = config->getMode();
	RealHostMatrix benign, benign_small;
	std::vector<RealHostMatrix> d_smallArray;
	int size = 505;
	int chunk = 1;
	std::string line;
	int i = 0;
	RealHostMatrix input;
	int nOutputs = (int)desiredOutputs.Columns();
	auto classes = (nOutputs == 1) ? 2 : nOutputs;
	NeuralNetworkTest test(classes);
	input.ResizeWithoutPreservingData(1, size);

	benign.ResizeWithoutPreservingData(benignsLines, size);
	benign_small.ResizeWithoutPreservingData(1, size);
	while (std::getline(Stream, line)) {
		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			benign_small(0, index) = strtod(it.c_str(), 0);
			index++;
		}
		d_smallArray.push_back(benign_small);
		i++;
	}

	for (int j = 0; j < d_smallArray.size(); j++)
	{
		auto column = d_smallArray[j];
		for (auto i = 0; i < column.Columns(); i++) {
			input(0, i) = column(0, i);
		}
		auto outputs = n.GetOutputs(input);

		#ifdef __DEBUG
			for (int i = 0; i < outputs.Rows(); i++) {
				for (int j = 0; j < outputs.Columns(); j++) {
					std::cout << outputs(i, j);
					std::cout << " ";
				}
			}
		#endif

		int nOutputs = (int)outputs.Columns();
		int patterns = (int)outputs.Rows();

		for (int p = 0; p < patterns; p++) {
			int predicted = -1;
			int correct = -1;

			double max = -1.0;

			if (nOutputs > 1) {
				for (int o = 0; o < nOutputs; o++) {
					if (desiredOutputs(p, o) >= 0.07)
						correct = o;
					double output = outputs(p, o);
					if (output > max) {
						predicted = o;
						max = output;
					}
				}
			}
			else 
			{
				if(direction)
					predicted = (outputs(p, 0) < minValue) ? 0 : 1;
				else
					predicted = (outputs(p, 0) < minValue) ? 0 : 1;

				correct = (desiredOutputs(p, 0) < minValue) ? 0 : 1;
			}
			test.Classify(correct, predicted);
		}
	}

	//test.Show();
	//std::cout << "Accuracy" << test.Accuracy() << std::endl;
	//std::cout << "Precision" << test.Precision() << std::endl;

	return test.Accuracy();
}

void MalwareAnalyzer::TestNeuralNetwork(const std::string& file,
	const std::string& database)
{
	OptimizedNeuralNetwork neural;

	std::ifstream Stream(file);
	size_t benignsLines = Utils::getNumberLines(Stream);
	auto config = ApplicationContext::instance()->getConfiguration();
	auto noEpocks = config->getEpocksLimit();
	auto mRMS = config->getRootMeanSquareMin();
	auto mode = config->getMode();
	RealHostMatrix benign, benign_small;
	std::vector<RealHostMatrix> d_smallArray;
	int size = 21104;
	int chunk = 1;
	std::string line;
	int i = 0;
	RealHostMatrix input;
	RealHostMatrix desiredOutputs(1, 1);
	desiredOutputs(0, 0);
	int nOutputs = (int)desiredOutputs.Columns();
	auto classes = (nOutputs == 1) ? 2 : nOutputs;
	NeuralNetworkTest test(classes);
	input.ResizeWithoutPreservingData(1, size);

	benign.ResizeWithoutPreservingData(benignsLines, size);
	benign_small.ResizeWithoutPreservingData(1, size);
	while (std::getline(Stream, line)) {
		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			benign_small(0, index) = strtod(it.c_str(), 0);
			index++;
		}
		d_smallArray.push_back(benign_small);
		i++;
	}
	auto n = neural.Load(database, IOStrategy::ASCII);

	for (int j = 0; j < d_smallArray.size(); j++)
	{
		auto column = d_smallArray[j];
		for (auto i = 0; i < column.Columns(); i++) {
			input(0, i) = column(0, i);
		}
		auto outputs = n.GetOutputs(input);

		#ifdef _DEBUG
				for (int i = 0; i < outputs.Rows(); i++) {
					for (int j = 0; j < outputs.Columns(); j++) {
						std::cout << outputs(i, j);
						std::cout << " ";
					}
				}
		#endif

		int nOutputs = (int)outputs.Columns();
		int patterns = (int)outputs.Rows();

		for (int p = 0; p < patterns; p++) {
			int predicted = -1;
			int correct = -1;

			double max = -1.0;

			if (nOutputs > 1) {
				for (int o = 0; o < nOutputs; o++) {
					if (desiredOutputs(p, o) >= 0.07)
						correct = o;
					double output = outputs(p, o);
					if (output > max) {
						predicted = o;
						max = output;
					}
				}
			}
			else {
				predicted = (outputs(p, 0) >= 0.5) ? 1 : 0;
				correct = (desiredOutputs(p, 0) >= 0.5) ? 1 : 0;
			}
			test.Classify(correct, predicted);
		}
	}

	//test.Show();
	std::cout << "Accuracy" << test.Accuracy() << std::endl;
	std::cout << "Precision" << test.Precision() << std::endl;

}

void MalwareAnalyzer::TrainNeuralNetworkFromBothDirectories(const std::string& directory,
	const std::string& benigns, const std::string& malware, const std::string& neuralNetworkOut)
{
	#if 0
		int m_index = 2;
		HostMatrix<cudafloat> inputs(m_index, 14058);
		HostMatrix<cudafloat> outputs(m_index, 1);

		for (int i = 0; i < 14058; i++) {
			for (int j = 0; j < m_index; j++) {
				inputs(j,i) = rand()%2;
			}	
		}
		outputs(0, 0) = 0;
		outputs(1, 0) = 1;

		TopologyOptimized topology2(4);
		topology2[0] = 14058;
		topology2[1] = 500;
		topology2[2] = 500;
		topology2[3] = 1;

		clock_t initialTime = clock();
		OptimizedNeuralNetwork n(topology2, inputs, outputs, 0.4, 0.00001);

		for (int i = 0; i < 1; i++) {
				n.Train(5);
				std::cout << "Inputs: " << i << " " ;
				std::cout << "Epochs: " << n.GetEpoch() << " ";
				std::cout << "RMS: " << n.GetRMS()  << std::endl;
				
				for (int i = 0; i < 14058; i++) {
					for (int j = 0; j < m_index; j++) {
						inputs(j, i) = rand() % 2;
					}
				}
				OptimizedNeuralNetwork n2(topology2, inputs, outputs, 0.4, 0.00001);
				for (auto k = 0; k < n.GetNumbersLayers(); k++) {
					auto weights = n.GetWeights(k);
					n2.SetWeights(weights, k);
				}

				n2.Train(5);
				std::cout << "Inputs: " << i << " ";
				std::cout << "Epochs: " << n2.GetEpoch() << " ";
				std::cout << "RMS: " << n2.GetRMS() << std::endl;

				for (int i = 0; i < 14058; i++) {
					for (int j = 0; j < m_index; j++) {
						inputs(j, i) = rand() % 2;
					}
				}
				OptimizedNeuralNetwork n3(topology2, inputs, outputs, 0.4, 0.00001);
				for (auto k = 0; k < n2.GetNumbersLayers(); k++) {
					auto weights = n2.GetWeights(k);
					n3.SetWeights(weights, k);
				}

				n3.Train(5);
				std::cout << "Inputs: " << i << " ";
				std::cout << "Epochs: " << n3.GetEpoch() << " ";
				std::cout << "RMS: " << n3.GetRMS() << std::endl;

				for (int i = 0; i < 14058; i++) {
					for (int j = 0; j < m_index; j++) {
						inputs(j, i) = rand() % 2;
					}
				}
		}
		cudaThreadSynchronize();
		unsigned time = (clock() - initialTime);
		std::cout << n.GetEpoch() << "\t" << (double)time / CLOCKS_PER_SEC << "s\t " << n.GetRMS() << "\t";


		auto output = n.GetOutputs(inputs);

		for (auto i = 0; i < output.Rows(); i++) {
			for (auto j = 0; j < output.Columns(); j++) {
				std::cout << output(i, j) << " ";
			}
		}
	#endif

	std::string s;
	int index = 0;
	int threeshold = 0.01;
	auto config = ApplicationContext::instance()->getConfiguration();
	auto test = config->getDirectoryBase() + "\\" + config->getTestDirectory();
	auto directoryTest = directory + config->getTestDirectory();

	std::ifstream benignsStream(directory + "\\" + benigns + ".txt");
	std::ifstream malwareStream(directory + "\\" + malware + ".txt");
	std::ifstream testBenignsStream(test + "\\" + benigns + ".txt");
	std::ifstream testMalwareStream(test + "\\" + malware + ".txt");

	auto noEpocks = config->getEpocksLimit();
	auto mRMS = config->getRootMeanSquareMin();
	auto mode = config->getMode();

	OptimizedNeuralNetwork*	network2 = nullptr;

	std::string line;

	RealHostMatrix d, m, d_small, test_benigns,test_malware,m_small;
	std::vector<RealHostMatrix> d_smallArray;
	RealHostMatrix input;
	bool isBenign = true;
	int i = 0;
	size_t benignsLines = Utils::getNumberLines(benignsStream);
    size_t malewareLines = Utils::getNumberLines(malwareStream);
	size_t benignsTestLines = Utils::getNumberLines(testBenignsStream);
	size_t malwareTestLines = Utils::getNumberLines(testMalwareStream);
	int size = 21104;
	int chunk = 1;
	int start = 0;

	d.ResizeWithoutPreservingData(benignsLines, size);
	m.ResizeWithoutPreservingData(malewareLines, size);
	test_benigns.ResizeWithoutPreservingData(benignsTestLines, size);
	test_malware.ResizeWithoutPreservingData(malwareTestLines, size);
	d_small.ResizeWithoutPreservingData(chunk, size);

	int j = 0;
	while (std::getline(benignsStream, line)) {
		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			d(i, index) = strtod(it.c_str(), 0);
			d_small(0,index) = strtod(it.c_str(), 0);
			index++;
		}
		d_smallArray.push_back(d_small);
		i++;
		if (i == 20)
			break;
	}
	i = 0;
	int index_malware = d_smallArray.size();
	while (std::getline(malwareStream, line)) {

		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			d_small(0, index) = strtod(it.c_str(), 0);
			index++;
		}
		d_smallArray.push_back(d_small);
		i++;
	}
	i = 0;
	while (std::getline(testBenignsStream, line)) {

		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			auto value = strtod(it.c_str(), 0);
			test_benigns(i, index++) = value;
		}
		i++;
	}
	i = 0;
	while (std::getline(testMalwareStream, line)) {

		auto ArrayStrings = Utils::Split(line, ' ');
		int index = 0;
		for (auto it : ArrayStrings) {
			auto value = strtod(it.c_str(), 0);
			test_malware(i, index++) = value;
		}
		i++;
	}

	input.ResizeWithoutPreservingData(1, test_benigns.Columns());
	std::vector<RealCpuArray> array;
	// We have the matrix train...
	if (mode == "OPTIMIZED_GPU") {

		RealHostMatrix desiredOutputs(chunk, 1);
		RealHostMatrix desiredOutputsMalware(chunk, 1);
		int nOutputs = (int)desiredOutputs.Columns();

		auto classes = (nOutputs == 1) ? 2 : nOutputs;
		NeuralNetworkTest test(classes);
		desiredOutputs(0, 0) = 0.0f;
			
		j = 0;
		int sizeInputs = d.Columns();
		TopologyOptimized topology(4);
		topology[0] = size;
		topology[1] = 1100;
		topology[2] = 700;
		topology[3] = 1;
		OptimizedNeuralNetwork network1(topology,
			d_smallArray[j++], desiredOutputs, 0.7, mRMS);
		
		while (j < d_smallArray.size())
		{
				array.clear();
				network1.Train(2);
				auto rms = network1.GetRMS();
				std::cout << "Inputs: " << i << " ";
				std::cout << "Epochs: " << network1.GetEpoch() << " ";
				std::cout << "RMS: " << rms << std::endl;

			for (auto k = 0; k < network1.GetNumbersLayers(); k++) {
				auto weights = network1.GetWeights(k);
				array.push_back(weights);
			}
			if (j == index_malware) {
				desiredOutputs(0, 0) = 1.0f;
			}
			OptimizedNeuralNetwork network1(topology, d_smallArray[j], desiredOutputs, 0.4, 0.00001);
			for (auto k = 0; k < network1.GetNumbersLayers(); k++) { 
				auto weights = array[k];
				network1.SetWeights(weights, k);
			}
			j++;
		}
		for (auto k = 0; k < array.size(); k++) {
			network1.SetWeights(array[k],k);
		}
		TestNeuralNetwork(directoryTest + "\\benigns.txt", network1,desiredOutputs,0.001,true);
		
		/*
		//Test the network
		for (int j = 0; j < test_malware.Rows(); j++)
		{
			for (auto i = 0; i < test_malware.Columns(); i++) {
				input(0, i) = test_malware(j, i);
			}
			auto outputs = network1.GetOutputs(input);

			#ifdef _DEBUG
				for (int i = 0; i < outputs.Rows(); i++) {
					for (int j = 0; j < outputs.Columns(); j++) {
						std::cout << outputs(i, j);
						std::cout << " ";
					}
				}
			#endif

			int nOutputs = (int)outputs.Columns();
			int patterns = (int)outputs.Rows();

			for (int p = 0; p < patterns; p++) {
				int predicted = -1;
				int correct = -1;

				double max = -1.0;

				if (nOutputs > 1) {
					for (int o = 0; o < nOutputs; o++) {
						if (desiredOutputs(p, o) >= 0.07)
							correct = o;
						double output = outputs(p, o);
						if (output > max) {
							predicted = o;
							max = output;
						}
					}
				}
				else {
					predicted = (outputs(p, 0) >= 0.5) ? 1 : 0;
					correct = (desiredOutputs(p, 0) >= 0.5) ? 1 : 0;
				}
				test.Classify(correct, predicted);
			}
		}
		
		//test.Show();
		std::cout << "Accuracy" << test.Accuracy() << std::endl;
		std::cout << "Precision" << test.Precision() << std::endl;


		//Create the network
		//	outputs(0, 0) = 1.0f;
		//	network2 = new OptimizedNeuralNetwork(topology, m, outputs, 0.4, mRMS);
		//	network2->Train(400);
		*/
		system("pause");

	}
	
	//network1.Save("ben_" + neuralNetworkOut,IOStrategy::ASCII);
	//network2->Save("malw_" + neuralNetworkOut, IOStrategy::ASCII);


}

void MalwareAnalyzer::BuildDataFromDirectory(const std::string& directory,const std::string& file_out)
{
	std::vector<std::string> vArray;
	Utils::ReadDirectory(directory, vArray);
	std::string s;
	int index = 0;
	int size = vArray.size();
	std::ofstream os(file_out);
	int no = 0;
	int zero = 0;
	for (auto & filename : vArray) {
		if (filename == "." || filename == "..")
			continue;
		parsed_pe *p = ParsePEFromFile((directory + "\\" + filename).c_str());
		PEIterator::pe = p;
		if (p == nullptr)
		{
			std::cout << "Filename: " + filename + "no pe" << std::endl;
			no++;
			continue; // no pe format maybe
		}
		/*Load the strings from the file*/
		auto arrayStrings = LoadStringsFromExe(p);

		auto vData = this->wordProcessor.MatchAgainst(arrayStrings);
		if (arrayStrings.size() == 0)
		{
			zero++;
			continue;
		}
			
		int ones = arrayStrings.size();
		int testOnes = 0;
		for (auto i : vData)
		{
			os << i << " ";
			if (i == 1.0f)
				testOnes++;
		}
		os << std::endl;
		assert(testOnes == ones);

		std::cout << "Processing file " + filename + " " +
			std::to_string((float)index / size) << std::endl;

		index++;
	}
	std::cout << "All filenames = " + index << std::endl;;
	std::cout << "No PE = " << no << std::endl;
	std::cout << "Array strings = " << zero << std::endl;
	os.close();
}

