#include "MalwareAnalyzer.h"
#include "NeuralNetwork.h"
#include "OptimizedNeuralNetwork.h"
#include <fstream>
#include "StringModel.h"

using namespace gpuNN;

vStrings PEIterator::ss;
parsed_pe * PEIterator::pe;

extern std::vector<const char*> gpuNN::excludedImports = { 
	"MSVCP140D.DLL","MSVCP140.DLL",
	"MSVCP120.DLL",
	"MSVCP120D.DLL" };

extern std::vector<const char*> gpuNN::excludedStrings = {
	"NULL",
	"std"
};

extern  std::vector<std::string> gpuNN::filteredStrings = {
	"@",
	"ORDINAL_MFC42U.DLL"
};

MalwareAnalyzer::MalwareAnalyzer()
{

}

MalwareAnalyzer::~MalwareAnalyzer()
{
}

void MalwareAnalyzer::Analyze(INeuralNetwork* network)
{	
	network->Train(this->iterationNumber);	
}

vStrings MalwareAnalyzer::LoadStringsFromExe(parsed_pe* pe)
{
	IterImpVAString(pe,PEIterator::printImports,NULL);
	
	IterSec(pe, PEIterator::printSecs, NULL);

	return std::move(PEIterator::ss);
}

void MalwareAnalyzer::BuildFeatures(const std::string& filename, INeuralNetwork*& network)
{
	parsed_pe *p = ParsePEFromFile(filename.c_str());
	PEIterator::pe = p;
	if (p == nullptr)
		return; // no pe format maybe
	auto arrayStrings = LoadStringsFromExe(p);
	if (arrayStrings.size() == 0)
		return;
	auto& sequenceModel = this->wordProcessor.BuildModel(arrayStrings);
	
	auto vModel = sequenceModel.toVector();
	auto context = ApplicationContext::instance();
	auto mode = context->getConfiguration()->getMode();

	if (mode == "CPU" || mode == "GPU")
	{
		/*Create a topology with size of the array as input and two outputs*/
		std::vector<size_t> topology = { vModel.size(),8,8,8,8,2 };
		network = new NeuralNetwork(topology, 1, 0.05, 1);
		network->SetCurrentInput(vModel);
		network->SetCurrentTarget({1});
	}

	if (mode == "OPTIMIZED_GPU")
	{
		RealHostMatrix input(1, vModel.size());

		for (auto i = 0; i < vModel.size(); i++) {
			input(0, i) = vModel[i];
		}
		
		RealHostMatrix outputs(1, 1);
		outputs(0,0) = 1.0f;
		
		TopologyOptimized topology(4);
		
		topology[0] = vModel.size();
		topology[1] = 30;
		topology[2] = 10;
		topology[3] = 1;

		network = new OptimizedNeuralNetwork(topology, input, outputs, 0.7);
		
	}


}

void MalwareAnalyzer::BuildFeatures(const std::string& filename, const std::string& out){
	
	parsed_pe *p = ParsePEFromFile(filename.c_str());
	PEIterator::pe = p;
	if (p == nullptr)
		return; // no pe format maybe
	auto arrayStrings = LoadStringsFromExe(p);
	auto& sequenceModel = this->wordProcessor.BuildModel(arrayStrings);

	ISequenceModel* model = new StringModel(arrayStrings);

	auto vModel = model->toVector();
	std::ofstream os(out);
	for (auto & iterator : vModel) {
		os << iterator;
	}
	os.close();
}

void MalwareAnalyzer::BuildFeaturesFromDirectory(const std::string& directory, 
	const std::string& database)
{
	std::vector<std::string> vArray;
	Utils::ReadDirectory(directory, vArray);
	std::string s;
	int index = 0;
	int size = vArray.size();
	for (auto & filename : vArray) 
	{
		if (filename == "." || filename == "..") 
			continue;
		parsed_pe *p = ParsePEFromFile((directory + "\\" + filename).c_str());
		PEIterator::pe = p;
		if (p == nullptr)
			continue; // no pe format maybe
		auto arrayStrings = LoadStringsFromExe(p);
		this->wordProcessor.CreateAndAppendModel(arrayStrings);
		std::cout << "Processing file " + filename + " " + 
			std::to_string((float)index / size) << std::endl;
		index++;
	}
	this->wordProcessor.OnFinish(database);
}