#pragma once
#include "includes.h"
#include "IAnalyzer.h"
#include "HuffmanWordProcessor.h"
#include <initializer_list>


namespace gpuNN {

	extern std::vector<const char*> excludedImports;

	class PEIterator {
		
	public:
		static parsed_pe * pe;
		static vStrings ss;

		static int printImports(void *N, VA impAddr, std::string &modName, std::string &symName) {
			static_cast<void>(N);
			
			if (std::find(excludedImports.begin(), excludedImports.end(), modName) == excludedImports.end()) {
				ss.emplace_back(symName);
			}
			return 0;
		}	
		
		static int printSecs(void *N,
			VA secBase,
			std::string &secName,
			image_section_header s,
			bounded_buffer *data) 
		{
			static_cast<void>(N);
			static_cast<void>(s);

			if (secName == ".data")
			{
				std::string test;
				for (std::size_t i = 0;; i++) 
				{
					::uint8_t b;
					bool outOfSection = ReadByteAtVA(pe, i + secBase, b);
					if (outOfSection == false)
						break;
					char ch = (char)b;
					if (Utils::isAscii(ch)) {
						test.push_back(ch);
					}
					else{
						if (test.size() > 2)
							ss.push_back(test);
						test = "";
					}
				}
			}
			if (secName == ".code")
			{

			}

			return 0;
		}
	};
	
	class MalwareAnalyzer :
		public IAnalyzer{
	
	private :
		HuffmanWordProcessor wordProcessor;
		int iterationNumber = 200;
	public:
		MalwareAnalyzer();
		virtual ~MalwareAnalyzer();
		void BuildFeatures(const std::string& filename, INeuralNetwork*& network);
		virtual void Analyze(INeuralNetwork* network);
	protected:
		/// <summary>
		/// Loads the string from the specified PE strucuture
		/// </summary>
		/// <param name="pe">The pe structure of the exec</param>
		/// <returns>An array of strings</returns>
		vStrings LoadStringsFromExe(parsed_pe* pe);
	};
}