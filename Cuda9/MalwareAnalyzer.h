#pragma once
#include "includes.h"
#include "IAnalyzer.h"
#include "HuffmanWordProcessor.h"
#include <initializer_list>
#include "FileLenghtEncoding.h"
#include "OptimizedNeuralNetwork.h"

namespace gpuNN {

	extern std::vector<const char*> excludedImports;
	extern std::vector<const char*> excludedStrings;
	extern std::vector<std::string> filteredStrings;

	class PEIterator {

	public:
		static parsed_pe * pe;
		static vStrings ss;

		static int printImports(void *N, VA impAddr, std::string &modName,
			std::string &symName) {
			static_cast<void>(N);

			
			if (std::find_if(filteredStrings.begin(), filteredStrings.end(),
				[&symName](const std::string& rhs){
				return symName.find(rhs) != -1;}) != filteredStrings.end()){
					return 0;
			}

			if (std::find(excludedImports.begin(), excludedImports.end(), modName) 
				== excludedImports.end()) {
				if (std::find(ss.begin(), ss.end(), symName) == ss.end())
						ss.emplace_back(symName);
			}
			return 0;
		}	
		
		static int printSecs(void *N,
			VA secBase,
			std::string &secName,
			image_section_header s,
			bounded_buffer *data) 
		{
			static_cast<void>(N);
			static_cast<void>(s);

			if (secName == ".data")
			{
				std::string test;
				for (std::size_t i = 0;; i++) 
				{
					::uint8_t b;
					bool outOfSection = ReadByteAtVA(pe, i + secBase, b);
					if (outOfSection == false)
						break;
					char ch = (char)b;
					if (Utils::isAscii(ch)) {
						test.push_back(ch);
					}
					else
					{
						if(std::find_if(filteredStrings.begin(),filteredStrings.end(),
							[test](const std::string& rhs) {
							return test.find(rhs) > 0;
						}) == filteredStrings.end()) {
							continue;
						}
						if (test.size() > 4 && test.size() < 15)
						{
							if (std::find(excludedStrings.begin(), excludedStrings.end(), test) 
								== excludedStrings.end()) 
							{
								if(std::find(ss.begin(),ss.end(),test) == ss.end())
									ss.push_back(test);
							}
						}
						test = "";
					}
				}
			}
			if (secName == ".code")
			{

			}

			return 0;
		}
	};
	
	class MalwareAnalyzer :
		public IAnalyzer{
	
	private :
		#ifdef HUFFMAN
				HuffmanWordProcessor wordProcessor;
		#else
				FileLenghtEncoding   wordProcessor;
		#endif
		int iterationNumber = 70;
		int Filter_Min = 400;
		int Target_Input = 1000;

	public:
		MalwareAnalyzer();
		virtual ~MalwareAnalyzer();
		/// <summary>
		/// Build the given 
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="network"></param>
		void BuildFeatures(const std::string& filename, 
			INeuralNetwork*& network,bool isBening = true);
		/// <summary>
		/// Analyze the data with the given neural network
		/// </summary>
		/// <param name="network"></param>
		virtual void Analyze(INeuralNetwork* network);
		/// <summary>
		/// Build the features from the provided filename and write them into the out file
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="out"></param>
		void BuildFeatures(const std::string& filename, const std::string& out);
		/// <summary>
		/// Buidl the features useing SLF encdoing
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="out"></param>
		void BuildFeaturesFromDirectory(const std::string& directory, 
			const std::string& database);

		// Builds the data from directory and store them into the file_out
		void BuildDataFromDirectory(const std::string& directory,
			const std::string& file_out);

		/// <summary>
		/// Train the neural network using the source directory.The database is loaded from the
		/// config file
		/// </summary>
		/// <param name="directory">The directory base</param>
		/// <param name="benigns">The benign folder</param>
		/// <param name="viruses">The viruses folder</param>
		/// <param name="neuralNetworkOut">The neural network file out</param>
		void TrainNeuralNetworkFromBothDirectories(const std::string& directory,
			const std::string& benigns, const std::string& viruses,
			const std::string& neuralNetworkOut);

		void TrainNeuralNetwork(const std::string& directory,const std::string& rhs,bool save);
		/// <summary>
		/// 
		/// </summary>
		void TestNeuralNetwork(const std::string& file,
			const std::string& database);

		float TestNeuralNetwork(const std::string& file,OptimizedNeuralNetwork& neural,
			RealHostMatrix,float min,bool);

		float TrainNeuralNetwork(const std::string& directory, const std::string& rhs,
			float rms, float hiddenLayer, float treeshold);

		protected:
		/// <summary>
		/// Loads the string from the specified PE strucuture
		/// </summary>
		/// <param name="pe">The pe structure of the exec</param>
		/// <returns>An array of strings</returns>
		vStrings LoadStringsFromExe(parsed_pe* pe);

	};
}