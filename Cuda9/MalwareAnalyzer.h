#pragma once
#include "includes.h"
#include "IAnalyzer.h"
#include "HuffmanWordProcessor.h"
#include <initializer_list>
#include "FileLenghtEncoding.h"
#include "OptimizedNeuralNetwork.h"
#include "include\udis86.h"

using namespace peparse;


namespace gpuNN {

	extern std::vector<const char*> excludedImports;
	extern std::vector<const char*> excludedStrings;
	extern std::vector<std::string> filteredStrings;
	extern std::vector<types::uint8_t>    filteredAssembly;

	class X86_64_Decoder;
	
	class X86_64_Decoder {

		ud_t processor;
		_parsed_pe* pe;
	public:
		X86_64_Decoder(types::uint8_t* buffer, size_t size, parsed_pe * pe)
		{
			ud_init(&processor);
			ud_set_input_buffer(&processor, buffer, size);
			ud_set_mode(&processor, 64);
			ud_set_syntax(&processor, UD_SYN_INTEL);
			this->pe = pe;
		}
		X86_64_Decoder(std::vector<types::uint8_t>& buffer, parsed_pe * pe)
		{
			ud_init(&processor);
			ud_set_input_buffer(&processor, buffer.data(), buffer.size());
			ud_set_mode(&processor,64);
			ud_set_syntax(&processor, UD_SYN_INTEL);
			this->pe = pe;
		}

		std::vector<std::string> Decode()
		{
			int i = 0;
			std::vector<std::string> vArray;
			while (ud_disassemble(&processor)) {

				std::string operand = ud_insn_asm(&processor);
				if (operand.find("call") != std::string::npos) {
			
					auto elms = Utils::Split(operand, ' ');
					if (elms[0] != "call") continue;
					if (elms.size() > 2) {
						
						// we have an 
						auto elmRaw = elms[3]; // call qword near [rip+address]
						size_t size = elmRaw.size() - 6;
						if (size > 40)
							continue;
						auto elm = elmRaw.substr(5,size);
						long val = strtol(elm.c_str(), NULL, 16);
						
						vArray.push_back(ReadImport(pe, val));
					}
				}
				else
				{
					auto elms = Utils::Split(operand, ' ');
					auto opCode = elms[0];
					if(opCode != "int3")
						vArray.push_back(opCode);
				}
			}
			return vArray;
		}
	};

	class PEIterator {

	public:
		static parsed_pe * pe;
		static vStrings ss;
		static vStrings ssText;

		static int printImports(void *N, VA impAddr, std::string &modName,
			std::string &symName) {
			static_cast<void>(N);

			//std::cout << modName << " " << symName << " " << impAddr << std::endl;;
			
			if (std::find_if(filteredStrings.begin(), filteredStrings.end(),
				[&symName](const std::string& rhs){
				return symName.find(rhs) != -1;}) != filteredStrings.end()){
					return 0;
			}

			if (std::find(excludedImports.begin(), excludedImports.end(), modName) 
				== excludedImports.end()) {
				if (std::find(ss.begin(), ss.end(), symName) == ss.end())
						ss.emplace_back(symName);
			}
			return 0;
		}	
		
		static int printSecs(void *N,
			VA secBase,
			std::string &secName,
			image_section_header s,
			bounded_buffer *data) 
		{
			static_cast<void>(N);
			static_cast<void>(s);

			if (secName == ".data" || secName == ".rdata" || secName == ".pdata" || secName == ".bss")
			{
				std::string test;
				for (std::size_t i = 0;; i++) 
				{
					::uint8_t b;
					bool outOfSection = ReadByteAtVA(pe, i + secBase, b);
					if (outOfSection == false)
						break;
					char ch = (char)b;
					if (Utils::isAscii(ch)) {
						test.push_back(ch);
					}
					else
					{
						if(std::find_if(filteredStrings.begin(),filteredStrings.end(),
							[test](const std::string& rhs) {
							return test.find(rhs) > 0;
						}) == filteredStrings.end()) {
							continue;
						}
						if (test.size() > 4 && test.size() < 15)
						{
							if (std::find(excludedStrings.begin(), excludedStrings.end(), test) 
								== excludedStrings.end()) 
							{
								if(std::find(ss.begin(),ss.end(),test) == ss.end())
									ss.push_back(test);
							}
						}
						test = "";
					}
				}
			}
			
			if (secName == ".text" || secName == ".code")
			{
				std::string test;
				size_t index = 0;
				std::vector<types::uint8_t> instruction;
				bool pushMode = false;
				for (std::size_t i = 0;; i++)
				{
					::uint8_t b;
					bool outOfSection = ReadByteAtVA(pe, i + secBase, b);
					if (outOfSection == false)
						break;
					instruction.push_back(b);
				}
				X86_64_Decoder decoder(instruction,pe);
				ssText = decoder.Decode();
			}	
			return 0;
		}
	};


	
	class MalwareAnalyzer :
		public IAnalyzer{
	
	private :
		#ifdef HUFFMAN
				HuffmanWordProcessor wordProcessor;
		#else
				FileLenghtEncoding   wordProcessor;
				FileLenghtEncoding   wordProcessorInstruction;
		#endif
		int iterationNumber = 70;
		int Filter_Min = 400;
		int Target_Input = 1000;

	public:
		MalwareAnalyzer();
		virtual ~MalwareAnalyzer();
		/// <summary>
		/// Build the given 
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="network"></param>
		void BuildFeatures(const std::string& filename, 
			INeuralNetwork*& network,bool isBening = true);
		/// <summary>
		/// Analyze the data with the given neural network
		/// </summary>
		/// <param name="network"></param>
		virtual void Analyze(INeuralNetwork* network);
		/// <summary>
		/// Build the features from the provided filename and write them into the out file
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="out"></param>
		void BuildFeatures(const std::string& filename, const std::string& out);
		/// <summary>
		/// Buidl the features useing SLF encdoing
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="out"></param>
		void BuildFeaturesFromDirectory(const std::string& directory, 
			const std::string& database, const std::string& database2 = "");

		// Builds the data from directory and store them into the file_out
		void BuildDataFromDirectory(const std::string& directory,
			const std::string& file_out);

		/// <summary>
		/// Train the neural network using the source directory.The database is loaded from the
		/// config file
		/// </summary>
		/// <param name="directory">The directory base</param>
		/// <param name="benigns">The benign folder</param>
		/// <param name="viruses">The viruses folder</param>
		/// <param name="neuralNetworkOut">The neural network file out</param>
		void TrainNeuralNetworkFromBothDirectories(const std::string& directory,
			const std::string& benigns, const std::string& viruses,
			const std::string& neuralNetworkOut);

		void TrainNeuralNetwork(const std::string& directory,const std::string& rhs,bool save);
		/// <summary>
		/// 
		/// </summary>
		void TestNeuralNetwork(const std::string& file,
			const std::string& database);

		float TestNeuralNetwork(const std::string& file,OptimizedNeuralNetwork& neural,
			RealHostMatrix,float min,bool);

		float TrainNeuralNetwork(const std::string& directory, const std::string& rhs,
			float rms, float hiddenLayer, float treeshold);

		protected:
		/// <summary>
		/// Loads the string from the specified PE strucuture
		/// </summary>
		/// <param name="pe">The pe structure of the exec</param>
		/// <returns>An array of strings</returns>
		std::vector<vStrings> LoadStringsFromExe(parsed_pe* pe);

	};
}