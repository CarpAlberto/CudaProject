#pragma once
#include "includes.h"
#include "IAnalyzer.h"
#include "HuffmanWordProcessor.h"
#include <initializer_list>
#include "FileLenghtEncoding.h"


namespace gpuNN {

	extern std::vector<const char*> excludedImports;
	extern std::vector<const char*> excludedStrings;
	extern std::vector<std::string> filteredStrings;

	class PEIterator {
		
	public:
		static parsed_pe * pe;
		static vStrings ss;

		static int printImports(void *N, VA impAddr, std::string &modName, 
			std::string &symName) {
			static_cast<void>(N);
			

			if (modName.find('@') > 0 || modName.find("ORDINAL_MFC42U.DLL") > 0)
				return 0;
			if (std::find(excludedImports.begin(), excludedImports.end(), modName) 
				== excludedImports.end()) {
				ss.emplace_back(symName);
			}
			return 0;
		}	
		
		static int printSecs(void *N,
			VA secBase,
			std::string &secName,
			image_section_header s,
			bounded_buffer *data) 
		{
			static_cast<void>(N);
			static_cast<void>(s);

			if (secName == ".data")
			{
				std::string test;
				for (std::size_t i = 0;; i++) 
				{
					::uint8_t b;
					bool outOfSection = ReadByteAtVA(pe, i + secBase, b);
					if (outOfSection == false)
						break;
					char ch = (char)b;
					if (Utils::isAscii(ch)) {
						test.push_back(ch);
					}
					else
					{
						if(std::find_if(filteredStrings.begin(),filteredStrings.end(),
							[test](const std::string& rhs) {
							return test.find(rhs) > 0;
						}) == filteredStrings.end()) {
							continue;
						}
						if (test.size() > 4 && test.size() < 15) {
							if (std::find(excludedStrings.begin(), excludedStrings.end(), test)
								== excludedStrings.end()) {
								ss.push_back(test);
							}
						}
						test = "";
					}
				}
			}
			if (secName == ".code")
			{

			}

			return 0;
		}
	};
	
	class MalwareAnalyzer :
		public IAnalyzer{
	
	private :
		#ifdef HUFFMAN
				HuffmanWordProcessor wordProcessor;
		#else
				FileLenghtEncoding   wordProcessor;
		#endif
		int iterationNumber = 70;
		int Filter_Min = 400;
		int Target_Input = 1000;

	public:
		MalwareAnalyzer();
		virtual ~MalwareAnalyzer();
		/// <summary>
		/// Build the given 
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="network"></param>
		void BuildFeatures(const std::string& filename, INeuralNetwork*& network);
		/// <summary>
		/// Analyze the data with the given neural network
		/// </summary>
		/// <param name="network"></param>
		virtual void Analyze(INeuralNetwork* network);
		/// <summary>
		/// Build the features from the provided filename and write them into the out file
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="out"></param>
		void BuildFeatures(const std::string& filename, const std::string& out);
		/// <summary>
		/// Buidl the features useing SLF encdoing
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="out"></param>
		void BuildFeaturesFromDirectory(const std::string& directory, 
			const std::string& database);
		protected:
		/// <summary>
		/// Loads the string from the specified PE strucuture
		/// </summary>
		/// <param name="pe">The pe structure of the exec</param>
		/// <returns>An array of strings</returns>
		vStrings LoadStringsFromExe(parsed_pe* pe);
	};
}